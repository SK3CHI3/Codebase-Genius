"""
Documentation generator for Codebase Genius.
Generates markdown documentation from repository analysis with AI-powered enhancements.
"""

from typing import Dict, List, Optional
import os
from datetime import datetime
from dotenv import load_dotenv

# Load environment variables from project root
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
env_path = os.path.join(project_root, '.env')
load_dotenv(dotenv_path=env_path)

# Try to import Gemini AI
try:
    import google.generativeai as genai
    # Configure Gemini - check API key from environment
    api_key = os.getenv('GEMINI_API_KEY')
    if api_key and api_key.strip():
        try:
            genai.configure(api_key=api_key.strip())
            # Use gemini-2.5-flash for faster responses
            GEMINI_MODEL = genai.GenerativeModel('gemini-2.5-flash')
            GEMINI_AVAILABLE = True
        except Exception as e:
            print(f"Warning: Failed to configure Gemini: {e}")
            GEMINI_AVAILABLE = False
            GEMINI_MODEL = None
    else:
        GEMINI_AVAILABLE = False
        GEMINI_MODEL = None
except ImportError:
    GEMINI_AVAILABLE = False
    GEMINI_MODEL = None


class DocGenerator:
    """Generates markdown documentation from codebase analysis with AI enhancements."""
    
    def __init__(self):
        self.sections = []
        self.use_ai = GEMINI_AVAILABLE and GEMINI_MODEL is not None
    
    def generate_documentation(
        self,
        repo_info: Dict,
        file_tree: Dict,
        readme_summary: str,
        ccg_data: Dict,
        parsed_files: List[Dict]
    ) -> str:
        """
        Generate complete markdown documentation.
        
        Args:
            repo_info: Repository information (name, url, etc.)
            file_tree: File tree structure
            readme_summary: Summary of README
            ccg_data: Code Context Graph data
            parsed_files: List of parsed file structures
            
        Returns:
            Complete markdown documentation string
        """
        doc = []
        
        # Title
        doc.append(f"# {repo_info.get('name', 'Repository')} Documentation\n")
        doc.append(f"*Generated by Codebase Genius on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*\n")
        
        # Table of Contents
        doc.append("## Table of Contents\n")
        doc.append("- [Overview](#overview)")
        doc.append("- [Repository Structure](#repository-structure)")
        doc.append("- [Installation](#installation)")
        doc.append("- [Architecture](#architecture)")
        doc.append("- [Code Context Graph](#code-context-graph)")
        doc.append("- [Module Documentation](#module-documentation)")
        doc.append("- [API Reference](#api-reference)\n")
        
        # Overview (AI-enhanced)
        doc.append("## Overview\n")
        overview_text = self._generate_ai_overview(repo_info, readme_summary, parsed_files, ccg_data)
        doc.append(overview_text)
        doc.append(f"\n**Repository URL:** {repo_info.get('url', 'N/A')}\n")
        
        # Repository Structure
        doc.append("## Repository Structure\n")
        doc.append("```\n")
        doc.append(self._format_file_tree(file_tree))
        doc.append("```\n")
        
        # Installation (if README had installation info, otherwise generic)
        doc.append("## Installation\n")
        doc.append("```bash\n")
        doc.append(f"git clone {repo_info.get('url', 'repository-url')}\n")
        doc.append(f"cd {repo_info.get('name', 'repository')}\n")
        doc.append("pip install -r requirements.txt  # if applicable\n")
        doc.append("```\n")
        
        # Architecture (AI-enhanced)
        doc.append("## Architecture\n")
        arch_text = self._generate_ai_architecture(ccg_data, parsed_files)
        doc.append(arch_text)
        
        # Code Context Graph
        doc.append("## Code Context Graph\n")
        doc.append(self._generate_ccg_section(ccg_data))
        
        # Module Documentation (AI-enhanced)
        doc.append("## Module Documentation\n")
        module_docs = self._generate_ai_module_docs(parsed_files)
        doc.append(module_docs)
        
        # API Reference
        doc.append("## API Reference\n")
        doc.append(self._generate_api_reference(parsed_files, ccg_data))
        
        return "\n".join(doc)
    
    def _format_file_tree(self, tree: Dict, indent: int = 0) -> str:
        """Format file tree as string."""
        lines = []
        prefix = "  " * indent
        
        if tree['type'] == 'directory':
            lines.append(f"{prefix}{tree['name']}/")
            for child in tree.get('children', []):
                lines.append(self._format_file_tree(child, indent + 1))
        else:
            lines.append(f"{prefix}{tree['name']}")
        
        return "\n".join(lines)
    
    def _generate_architecture_section(self, ccg_data: Dict, parsed_files: List[Dict]) -> str:
        """Generate architecture overview section."""
        content = []
        
        # Count components
        if ccg_data:
            nodes = ccg_data.get('nodes', {})
            modules = sum(1 for n in nodes.values() if n.get('type') == 'module')
            classes = sum(1 for n in nodes.values() if n.get('type') == 'class')
            functions = sum(1 for n in nodes.values() if n.get('type') == 'function')
            
            content.append(f"The codebase consists of:\n")
            content.append(f"- **{modules}** modules")
            content.append(f"- **{classes}** classes")
            content.append(f"- **{functions}** functions\n")
        
        # Main entry points
        entry_points = []
        for parsed in parsed_files:
            if 'main.py' in parsed.get('file_path', '') or 'app.py' in parsed.get('file_path', ''):
                entry_points.append(parsed.get('file_path', ''))
        
        if entry_points:
            content.append("### Entry Points\n")
            for ep in entry_points:
                content.append(f"- `{ep}`\n")
        
        return "\n".join(content)
    
    def _generate_ccg_section(self, ccg_data: Dict) -> str:
        """Generate Code Context Graph visualization section."""
        content = []
        
        if not ccg_data or not ccg_data.get('nodes'):
            content.append("No code relationships detected.\n")
            return "\n".join(content)
        
        content.append("The Code Context Graph (CCG) represents relationships between code components.\n")
        
        # Generate a simple text-based diagram
        content.append("\n### Relationship Diagram\n")
        content.append("```\n")
        
        nodes = ccg_data.get('nodes', {})
        
        # Show inheritance relationships
        inheritance = []
        for node_id, node in nodes.items():
            if node.get('type') == 'class':
                for target_id, edge_type in node.get('edges', []):
                    if edge_type == 'inherits_from':
                        target_node = nodes.get(target_id)
                        if target_node:
                            inheritance.append(f"{node.get('name')} -> {target_node.get('name')} [inherits]")
        
        if inheritance:
            content.append("Inheritance Relationships:")
            for rel in inheritance[:10]:  # Limit to 10 for readability
                content.append(f"  {rel}")
        
        # Show call relationships (sample)
        calls = []
        for node_id, node in nodes.items():
            if node.get('type') == 'function':
                for target_id, edge_type in node.get('edges', []):
                    if edge_type == 'calls':
                        target_node = nodes.get(target_id)
                        if target_node:
                            calls.append(f"{node.get('name')}() -> {target_node.get('name')}()")
        
        if calls:
            content.append("\nFunction Call Relationships (sample):")
            for call in calls[:10]:  # Limit to 10
                content.append(f"  {call}")
        
        content.append("```\n")
        
        # Statistics
        content.append("\n### Graph Statistics\n")
        content.append(f"- Total nodes: {ccg_data.get('node_count', 0)}\n")
        
        return "\n".join(content)
    
    def _generate_module_docs(self, parsed_files: List[Dict]) -> str:
        """Generate module documentation."""
        content = []
        
        for parsed in parsed_files:
            if 'error' in parsed:
                continue
            
            module_name = parsed.get('module_name', 'Unknown')
            file_path = parsed.get('file_path', '')
            
            content.append(f"### {module_name}\n")
            content.append(f"**File:** `{file_path}`\n")
            
            # Classes
            classes = parsed.get('classes', [])
            if classes:
                content.append("\n#### Classes\n")
                for cls in classes:
                    content.append(f"- **{cls['name']}**")
                    if cls.get('bases'):
                        bases_str = ", ".join(cls['bases'])
                        content.append(f" (inherits from: {bases_str})")
                    content.append("\n")
            
            # Functions
            functions = parsed.get('functions', [])
            if functions:
                content.append("\n#### Functions\n")
                for func in functions:
                    content.append(f"- `{func['name']}()`\n")
            
            content.append("\n---\n")
        
        return "\n".join(content)
    
    def _generate_api_reference(self, parsed_files: List[Dict], ccg_data: Dict) -> str:
        """Generate API reference section."""
        content = []
        
        # Collect all public functions and classes
        public_items = []
        
        for parsed in parsed_files:
            if 'error' in parsed:
                continue
            
            for func in parsed.get('functions', []):
                if not func['name'].startswith('_'):  # Public functions
                    public_items.append({
                        'name': func['name'],
                        'type': 'function',
                        'module': parsed.get('module_name'),
                        'file': parsed.get('file_path')
                    })
            
            for cls in parsed.get('classes', []):
                if not cls['name'].startswith('_'):  # Public classes
                    public_items.append({
                        'name': cls['name'],
                        'type': 'class',
                        'module': parsed.get('module_name'),
                        'file': parsed.get('file_path')
                    })
        
        if public_items:
            content.append("### Public API\n")
            content.append("| Name | Type | Module |\n")
            content.append("|------|------|--------|\n")
            for item in sorted(public_items, key=lambda x: x['name']):
                content.append(f"| `{item['name']}` | {item['type']} | `{item['module']}` |\n")
        else:
            content.append("No public API items found.\n")
        
        return "\n".join(content)
    
    def save_documentation(self, content: str, output_path: str) -> bool:
        """Save documentation to file."""
        try:
            os.makedirs(os.path.dirname(output_path), exist_ok=True)
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(content)
            return True
        except Exception as e:
            print(f"Error saving documentation: {e}")
            return False
    
    def _call_gemini(self, prompt: str, max_retries: int = 3) -> Optional[str]:
        """Call Gemini API with error handling."""
        if not self.use_ai:
            return None
        
        for attempt in range(max_retries):
            try:
                response = GEMINI_MODEL.generate_content(prompt)
                return response.text
            except Exception as e:
                if attempt == max_retries - 1:
                    print(f"Gemini API error after {max_retries} attempts: {e}")
                    return None
                continue
        return None
    
    def _generate_ai_overview(self, repo_info: Dict, readme_summary: str, 
                              parsed_files: List[Dict], ccg_data: Dict) -> str:
        """Generate AI-enhanced overview section."""
        if not self.use_ai:
            if readme_summary:
                return readme_summary
            return f"This repository contains the source code for **{repo_info.get('name', 'the project')}**.\n"
        
        # Prepare context for AI
        repo_name = repo_info.get('name', 'the repository')
        file_count = len(parsed_files)
        modules = []
        for parsed in parsed_files[:5]:  # Limit to first 5 for context
            modules.append(parsed.get('module_name', 'Unknown'))
        
        prompt = f"""Generate a clear, professional overview for a software repository documentation.

Repository Name: {repo_name}
Repository URL: {repo_info.get('url', 'N/A')}
Number of analyzed files: {file_count}
Main modules: {', '.join(modules[:3])}

Existing README summary (if any):
{readme_summary[:500] if readme_summary else 'No README found'}

Generate a 2-3 paragraph overview that:
1. Describes what this repository/project does
2. Highlights key features or components
3. Provides context about the codebase structure
4. Is written in clear, professional technical documentation style

Write only the overview text, no markdown headers or formatting beyond what's needed for clarity."""

        ai_response = self._call_gemini(prompt)
        if ai_response:
            return ai_response.strip() + "\n"
        
        # Fallback to non-AI version
        if readme_summary:
            return readme_summary
        return f"This repository contains the source code for **{repo_name}**.\n"
    
    def _generate_ai_architecture(self, ccg_data: Dict, parsed_files: List[Dict]) -> str:
        """Generate AI-enhanced architecture description."""
        # First get the basic architecture data
        basic_arch = self._generate_architecture_section(ccg_data, parsed_files)
        
        if not self.use_ai:
            return basic_arch
        
        # Prepare context
        nodes = ccg_data.get('nodes', {}) if ccg_data else {}
        modules = sum(1 for n in nodes.values() if n.get('type') == 'module')
        classes = sum(1 for n in nodes.values() if n.get('type') == 'class')
        functions = sum(1 for n in nodes.values() if n.get('type') == 'function')
        
        # Get sample class and function names
        sample_classes = [n.get('name') for n in nodes.values() if n.get('type') == 'class'][:5]
        sample_functions = [n.get('name') for n in nodes.values() if n.get('type') == 'function'][:10]
        
        prompt = f"""Based on the following codebase statistics, generate an intelligent architecture overview:

Statistics:
- {modules} modules
- {classes} classes
- {functions} functions

Sample classes: {', '.join(sample_classes) if sample_classes else 'None'}
Sample functions: {', '.join(sample_functions[:5]) if sample_functions else 'None'}

Generate a 2-3 paragraph architecture description that:
1. Explains the overall structure and organization
2. Describes how components relate to each other
3. Highlights architectural patterns if evident
4. Provides insights about the codebase design

Write in clear, professional technical documentation style. Include the statistics naturally in the text."""

        ai_response = self._call_gemini(prompt)
        if ai_response:
            return ai_response.strip() + "\n\n" + basic_arch
        
        return basic_arch
    
    def _generate_ai_module_docs(self, parsed_files: List[Dict]) -> str:
        """Generate AI-enhanced module documentation."""
        content = []
        
        for parsed in parsed_files[:10]:  # Limit to first 10 modules for AI processing
            if 'error' in parsed:
                continue
            
            module_name = parsed.get('module_name', 'Unknown')
            file_path = parsed.get('file_path', '')
            classes = parsed.get('classes', [])
            functions = parsed.get('functions', [])
            
            content.append(f"### {module_name}\n")
            content.append(f"**File:** `{file_path}`\n")
            
            # Generate AI description for this module
            if self.use_ai and (classes or functions):
                class_names = [c['name'] for c in classes]
                func_names = [f['name'] for f in functions]
                
                prompt = f"""Generate a brief, clear description for a Python module in technical documentation.

Module: {module_name}
Classes: {', '.join(class_names) if class_names else 'None'}
Functions: {', '.join(func_names[:10]) if func_names else 'None'}

Write 1-2 sentences describing what this module does and its purpose. Be concise and technical."""

                ai_desc = self._call_gemini(prompt)
                if ai_desc:
                    content.append(f"\n{ai_desc.strip()}\n")
            
            # Classes
            if classes:
                content.append("\n#### Classes\n")
                for cls in classes:
                    content.append(f"- **{cls['name']}**")
                    if cls.get('bases'):
                        bases_str = ", ".join(cls['bases'])
                        content.append(f" (inherits from: {bases_str})")
                    content.append("\n")
            
            # Functions
            if functions:
                content.append("\n#### Functions\n")
                for func in functions:
                    content.append(f"- `{func['name']}()`\n")
            
            content.append("\n---\n")
        
        # Add remaining modules without AI (if any)
        if len(parsed_files) > 10:
            remaining = self._generate_module_docs(parsed_files[10:])
            content.append(remaining)
        
        return "\n".join(content)


